#include "digiproces-common.h"

/*******************************************************************************/

void system_init(void) {
    /**
     * Configure the 32 kHz pins, PD6 and PD7, for crystal operation
     * By default they are configured as GPIOs
     */
    GPIODirModeSet(GPIO_D_BASE, 0x40, GPIO_DIR_MODE_IN);
    GPIODirModeSet(GPIO_D_BASE, 0x80, GPIO_DIR_MODE_IN);
    IOCPadConfigSet(GPIO_D_BASE, 0x40, IOC_OVERRIDE_ANA);
    IOCPadConfigSet(GPIO_D_BASE, 0x80, IOC_OVERRIDE_ANA);

    /**
     * Set the real-time clock to use the 32khz internal crystal
     * Set the system clock to use the external 32 MHz crystal
     * Set the system clock to 32 MHz
     */
    SysCtrlClockSet(true, false, SYS_CTRL_SYSDIV_32MHZ);

    /**
     * Set the IO clock to operate at 16 MHz
     * This way peripherals can run while the system clock is gated
     */
    SysCtrlIOClockSet(SYS_CTRL_SYSDIV_16MHZ);

    /**
     * Wait until the selected clock configuration is stable
     */
    while (!((HWREG(SYS_CTRL_CLOCK_STA)) & (SYS_CTRL_CLOCK_STA_XOSC_STB)));
}

void gpio_init(void) {
    // Set GPIOs as output
    GPIOPinTypeGPIOOutput(GPIO_A_BASE, 0xFF);
    GPIOPinTypeGPIOOutput(GPIO_B_BASE, 0xFF);
    GPIOPinTypeGPIOOutput(GPIO_C_BASE, 0xFF);
    GPIOPinTypeGPIOOutput(GPIO_D_BASE, 0xFF);

    // Initialize GPIOs to low
    GPIOPinWrite(GPIO_A_BASE, 0xFF, 0x00);
    GPIOPinWrite(GPIO_B_BASE, 0xFF, 0x00);
    GPIOPinWrite(GPIO_C_BASE, 0xFF, 0x00);
    GPIOPinWrite(GPIO_D_BASE, 0xFF, 0x00);
}

void leds_init(void) {
    // Set LEDs GPIO as output
    GPIOPinTypeGPIOOutput(BSP_LED_BASE, BSP_LED_ALL);
    
    // Set all LEDs as off
    GPIOPinWrite(BSP_LED_BASE, BSP_LED_ALL, 0x00);
}

void button_init(void) {
    // Set button GPIO as input
	GPIOPinTypeGPIOInput(BSP_BUTTON_BASE, BSP_BUTTON_USER);
    IOCPadConfigSet(BSP_BUTTON_BASE, BSP_BUTTON_USER, IOC_OVERRIDE_PUE);

    // Configure GPIO interrupt on falling edge
    GPIOIntTypeSet(BSP_BUTTON_BASE, BSP_BUTTON_USER, GPIO_FALLING_EDGE);
    
    // Register the function to handle the interrupt
    GPIOPortIntRegister(BSP_BUTTON_BASE, button_toggle);
    
    // Clear any pending interrupt (just in case)
	GPIOPinIntClear(BSP_BUTTON_BASE, BSP_BUTTON_USER);
	
	// Enable the GPIO interrupt
    GPIOPinIntEnable(BSP_BUTTON_BASE, BSP_BUTTON_USER);

    // Enable the global interrupt
    IntEnable(BSP_BUTTON_USER);
}

void button_toggle(void) {
    static uint32_t led_status = 0;
    uint32_t int_status;
    
    // Check the interrupt line
    int_status = GPIOPinIntStatus(BSP_BUTTON_BASE, true);
    
    // Check the LED status and take action
    if (led_status) {
        GPIOPinWrite(BSP_LED_BASE, BSP_LED_RED, 0);
        led_status = 0;
    } else {
        GPIOPinWrite(BSP_LED_BASE, BSP_LED_RED, BSP_LED_RED);
        led_status = 1;
    }
    
    // Clear the interrupt line
    GPIOPinIntClear(BSP_BUTTON_BASE, int_status);
}

void antenna_init(void) {
    // Configure the ANT1 and ANT2 GPIO as output
    GPIOPinTypeGPIOOutput(BSP_ANTENNA_BASE, BSP_ANTENNA_INT);
    GPIOPinTypeGPIOOutput(BSP_ANTENNA_BASE, BSP_ANTENNA_EXT);

    // By default the chip antenna is selected as the default
    GPIOPinWrite(BSP_ANTENNA_BASE, BSP_ANTENNA_INT, BSP_ANTENNA_INT);
    GPIOPinWrite(BSP_ANTENNA_BASE, BSP_ANTENNA_EXT, 0);
}

void uart_init() {
   // Disable UART function
   UARTDisable(UART0_BASE);

   // Disable all UART module interrupts
   UARTIntDisable(UART0_BASE, 0x1FFF);

   // Set IO clock as UART clock source
   UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);

   // Map UART signals to the correct GPIO pins and configure them as
   // hardware controlled. GPIO-A pin 0 and 1
   IOCPinConfigPeriphOutput(GPIO_A_BASE, PIN_UART_TXD, IOC_MUX_OUT_SEL_UART0_TXD);
   GPIOPinTypeUARTOutput(GPIO_A_BASE, PIN_UART_TXD);
   IOCPinConfigPeriphInput(GPIO_A_BASE, PIN_UART_RXD, IOC_UARTRXD_UART0);
   GPIOPinTypeUARTInput(GPIO_A_BASE, PIN_UART_RXD);

   // Configure the UART for 115,200, 8-N-1 operation.
   // This function uses SysCtrlClockGet() to get the system clock
   // frequency.  This could be also be a variable or hard coded value
   // instead of a function call.
   UARTConfigSetExpClk(UART0_BASE, SysCtrlIOClockGet(), 115200,
                      (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                       UART_CONFIG_PAR_NONE));

   // Enable UART hardware
   UARTEnable(UART0_BASE);

   // Disable FIFO as we only one 1byte buffer
   UARTFIFODisable(UART0_BASE);
}

void uart_tx_message(uint8_t * message, uint16_t size) {
    while(size--) {
        UARTCharPut(UART0_BASE, *message);
    }
}

void antenna_external(void) {
    // Select the external antenna
    GPIOPinWrite(BSP_ANTENNA_BASE, BSP_ANTENNA_EXT, BSP_ANTENNA_EXT);
    GPIOPinWrite(BSP_ANTENNA_BASE, BSP_ANTENNA_INT, 0);
}

void antenna_internal(void) {
    // Select the internal antenna
    GPIOPinWrite(BSP_ANTENNA_BASE, BSP_ANTENNA_EXT, ~BSP_ANTENNA_EXT);
    GPIOPinWrite(BSP_ANTENNA_BASE, BSP_ANTENNA_INT, 0);
}

void regulator_init(void) {
    GPIOPinTypeGPIOOutput(BSP_VREG_BASE, BSP_VREG_GPIO);
    GPIOPinWrite(BSP_VREG_BASE, BSP_VREG_GPIO, BSP_VREG_GPIO);
}

void regulator_3V3(void) {
    GPIOPinWrite(BSP_VREG_BASE, BSP_VREG_GPIO, BSP_VREG_GPIO);
}

void regulator_2V1(void) {
    GPIOPinWrite(BSP_VREG_BASE, BSP_VREG_GPIO, ~BSP_VREG_GPIO);
}

void radio_init(void) {
   CC2538_RF_CSP_ISFLUSHRX();
   CC2538_RF_CSP_ISFLUSHTX();

   radio_off();

   //disable radio interrupts
   disable_radio_interrupts();

   /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
      * too many false frames are received if the reset value is used. Make it more likely to detect
      * sync by removing the requirement that both symbols in the SFD must have a correlation value
      * above the correlation threshold, and make sync word detection less likely by raising the
      * correlation threshold.
      */
   HWREG(RFCORE_XREG_MDMCTRL1) = 0x14;
   
   /* tuning adjustments for optimal radio performance; details available in datasheet */
   HWREG(RFCORE_XREG_RXCTRL) = 0x3F;

   /* Adjust current in synthesizer; details available in datasheet. */
   HWREG(RFCORE_XREG_FSCTRL) = 0x55;

     /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
      * details available in datasheet.
      */
   HWREG(RFCORE_XREG_MDMCTRL0) = 0x85;

   /* Adjust current in VCO; details available in datasheet. */
   HWREG(RFCORE_XREG_FSCAL1) = 0x01;
   
   /* Adjust target value for AGC control loop; details available in datasheet. */
   HWREG(RFCORE_XREG_AGCCTRL1) = 0x15;

   /* Tune ADC performance, details available in datasheet. */
   HWREG(RFCORE_XREG_ADCTEST0) = 0x10;
   HWREG(RFCORE_XREG_ADCTEST1) = 0x0E;
   HWREG(RFCORE_XREG_ADCTEST2) = 0x03;

   //update CCA register to -81db as indicated by manual.. won't be used..
   HWREG(RFCORE_XREG_CCACTRL0) = 0xF8;
   
   /*
    * Changes from default values
    * See User Guide, section "Register Settings Update"
    */
   HWREG(RFCORE_XREG_TXFILTCFG) = 0x09;    /** TX anti-aliasing filter bandwidth */
   HWREG(RFCORE_XREG_AGCCTRL1) = 0x15;     /** AGC target value */
   HWREG(ANA_REGS_O_IVCTRL) = 0x0B;        /** Bias currents */

   /* disable the CSPT register compare function */
   HWREG(RFCORE_XREG_CSPT) = 0xFFUL;
   
   /*
    * Defaults:
    * Auto CRC; Append RSSI, CRC-OK and Corr. Val.; CRC calculation;
    * RX and TX modes with FIFOs
    */
   HWREG(RFCORE_XREG_FRMCTRL0) = RFCORE_XREG_FRMCTRL0_AUTOCRC;

   //poipoi disable frame filtering by now.. sniffer mode.
   HWREG(RFCORE_XREG_FRMFILT0) &= ~RFCORE_XREG_FRMFILT0_FRAME_FILTER_EN;

   /* Disable source address matching and autopend */
   HWREG(RFCORE_XREG_SRCMATCH) = 0;

     /* MAX FIFOP threshold */
   HWREG(RFCORE_XREG_FIFOPCTRL) = CC2538_RF_MAX_PACKET_LEN;

   HWREG(RFCORE_XREG_TXPOWER) = CC2538_RF_TX_POWER;
   HWREG(RFCORE_XREG_FREQCTRL) = CC2538_RF_CHANNEL_MIN;

   //register interrupt
   IntRegister(INT_RFCORERTX, radio_isr);
   IntRegister(INT_RFCOREERR, radio_error_isr);

   IntPrioritySet(INT_RFCORERTX, HAL_INT_PRIOR_MAC);
   IntPrioritySet(INT_RFCOREERR, HAL_INT_PRIOR_MAC);

   IntEnable(INT_RFCORERTX);

     /* Enable all RF Error interrupts */
   HWREG(RFCORE_XREG_RFERRM) = RFCORE_XREG_RFERRM_RFERRM_M; //all errors
   IntEnable(INT_RFCOREERR);
}

void radio_set_channel(uint8_t channel) {
   if((channel < CC2538_RF_CHANNEL_MIN) || (channel > CC2538_RF_CHANNEL_MAX)) {
	  while(1);
      return;
    }

    /* Changes to FREQCTRL take effect after the next recalibration */
   HWREG(RFCORE_XREG_FREQCTRL) = (CC2538_RF_CHANNEL_MIN
        + (channel - CC2538_RF_CHANNEL_MIN) * CC2538_RF_CHANNEL_SPACING);
}

